package chunk

import (
	"bytes"
	"testing"
	"time"

	"github.com/eientei/videostreamer/pkg/rtmp/message"
	"github.com/stretchr/testify/assert"
)

func TestWriteMessage_FullSimple(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x03,
			Timestamp: epoch.Add(0x11 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{'b', 'a', 'k', 'a'},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x03 | (HeaderFormatFull << 6),
		0x00, 0x00, 0x11,
		0x00, 0x00, 0x04,
		0x10,
		0x00, 0x00, 0x00, 0x01,
		'b', 'a', 'k', 'a',
	}, bs.Bytes())
}

func TestWriteMessage_FullExtended(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	chs.ChunkMap[3] = &Chunk{
		ID:        0x03,
		Length:    0,
		TypeID:    0,
		StreamID:  0,
		Timestamp: 0,
		Delta:     0,
	}
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x03,
			Timestamp: epoch.Add(0x1000000 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{'b', 'a', 'k', 'a'},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x03 | (HeaderFormatFull << 6),
		0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0x04,
		0x10,
		0x00, 0x00, 0x00, 0x01,
		0x01, 0x00, 0x00, 0x00,
		'b', 'a', 'k', 'a',
	}, bs.Bytes())
}

func TestWriteMessage_MediumSimple(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	chs.ChunkMap[3] = &Chunk{
		ID:        0x03,
		Length:    0,
		TypeID:    0,
		StreamID:  0x01,
		Timestamp: 0x01,
		Delta:     0,
	}
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x03,
			Timestamp: epoch.Add(0x11 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{'b', 'a', 'k', 'a'},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x03 | (HeaderFormatMedium << 6),
		0x00, 0x00, 0x10,
		0x00, 0x00, 0x04,
		0x10,
		'b', 'a', 'k', 'a',
	}, bs.Bytes())
}

func TestWriteMessage_MediumExtended(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	chs.ChunkMap[3] = &Chunk{
		ID:        0x03,
		Length:    0,
		TypeID:    0,
		StreamID:  0x01,
		Timestamp: 0x01,
		Delta:     0,
	}
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x03,
			Timestamp: epoch.Add(0x1000001 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{'b', 'a', 'k', 'a'},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x03 | (HeaderFormatMedium << 6),
		0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0x04,
		0x10,
		0x01, 0x00, 0x00, 0x00,
		'b', 'a', 'k', 'a',
	}, bs.Bytes())
}

func TestWriteMessage_ShortSimple(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	chs.ChunkMap[3] = &Chunk{
		ID:        0x03,
		Length:    0x04,
		TypeID:    0x10,
		StreamID:  0x01,
		Timestamp: 0x01,
		Delta:     0,
	}
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x03,
			Timestamp: epoch.Add(0x11 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{'b', 'a', 'k', 'a'},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x03 | (HeaderFormatShort << 6),
		0x00, 0x00, 0x10,
		'b', 'a', 'k', 'a',
	}, bs.Bytes())
}

func TestWriteMessage_ShortExtended(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	chs.ChunkMap[3] = &Chunk{
		ID:        0x03,
		Length:    0x04,
		TypeID:    0x10,
		StreamID:  0x01,
		Timestamp: 0x01,
		Delta:     0,
	}
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x03,
			Timestamp: epoch.Add(0x1000001 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{'b', 'a', 'k', 'a'},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x03 | (HeaderFormatShort << 6),
		0xFF, 0xFF, 0xFF,
		0x01, 0x00, 0x00, 0x00,
		'b', 'a', 'k', 'a',
	}, bs.Bytes())
}

func TestWriteMessage_None(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	chs.ChunkMap[3] = &Chunk{
		ID:        0x03,
		Length:    0x04,
		TypeID:    0x10,
		StreamID:  0x01,
		Timestamp: 0x01,
		Delta:     0x10,
	}
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x03,
			Timestamp: epoch.Add(0x11 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{'b', 'a', 'k', 'a'},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x03 | (HeaderFormatNone << 6),
		'b', 'a', 'k', 'a',
	}, bs.Bytes())
}

func TestWriteMessage_FormatTwo(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	chs.ChunkMap[0x130] = &Chunk{
		ID:        0x130,
		Length:    0x00,
		TypeID:    0x10,
		StreamID:  0x01,
		Timestamp: 0x01,
		Delta:     0x10,
	}
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x130,
			Timestamp: epoch.Add(0x11 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x00 | (HeaderFormatNone << 6),
		0xF0,
	}, bs.Bytes())
}

func TestWriteMessage_FormatThree(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	chs.ChunkMap[0xf041] = &Chunk{
		ID:        0xf041,
		Length:    0x00,
		TypeID:    0x10,
		StreamID:  0x01,
		Timestamp: 0x01,
		Delta:     0x10,
	}
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0xf041,
			Timestamp: epoch.Add(0x11 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x01 | (HeaderFormatNone << 6),
		0xF0, 0x01,
	}, bs.Bytes())
}

func TestWriteMessage_Multichunk(t *testing.T) {
	bs := &bytes.Buffer{}
	epoch := time.Now()
	chs := NewChunks(epoch, 0)
	err := chs.WriteMessage(bs, &message.Raw{
		Header: message.Header{
			ChunkID:   0x03,
			Timestamp: epoch.Add(0x11 * time.Millisecond),
			Type:      0x10,
			StreamID:  0x01,
		},
		Data: []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
		},
	})

	assert.NoError(t, err)
	assert.EqualValues(t, []byte{
		0x03 | (HeaderFormatFull << 6),
		0x00, 0x00, 0x11,
		0x00, 0x00, 0x90,
		0x10,
		0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16,
		0x03 | (HeaderFormatNone << 6),
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
	}, bs.Bytes())
}
